kabiparser
==========

This is a toolkit comprised of the following utilities.

makei.sh    - Uses the kernel make to compile preprocessor .i files.
              To save time, only files that have EXPORT_SYMBOL in them
              are processed.
              /usr/sbin/makei.sh

kabi-data.sh - A shell script wrapper for kabi-parser that invokes it for
               each .i file in the kernel tree. This shell script creates
               a list of files processed to be used by kabi-lookup tool.
               /usr/sbin/kabi-data.sh

kernel-make.patch - a patch for the kernel make that will obviate the
              need to use the two shell scripts named above. The make
              adds a new clean target, rh-clean-kabi, to remove the .i
              and .kb_dat files generated by the make.
              $HOME/kernel-make.patch

              From the top of your kernel git tree ...

              $ git apply $HOME/kernel-make.patch

kabi-parser - Parses preprocessor .i files for exported symbols and the
              compound data types on which they depend. The results for
              each .i file are serialized into a data file. Exported
              symbols and their entire dependency trees are recorded.

              The data files have the same name stem and reside in the
              same directory as their .i sources. The data is organized as
              as a map using a symbol's crc and its place in the hierarchy
              of its dependent exported symbol.

              Compound data types will include their backpointers, which
              introduces a bit of redundancy, but maximizes the data.
              Backpointers are followed to only one level below to avoid
              infinite recursion. Nested duplicates are also detected and
              limited for the same reason.
              /usr/sbin/kabi-parser

kabi-dump    - Dumps the contents of a serialized data file to make it
               humanly readable. It is really only a debugging tool.
               /usr/sbin/kabi-dump

kabi-lookup  - Utility that traverses the data files looking for symbols
               on which exported symbols depend. The searches are as follows.
               /usr/sbin/kabi-lookup

               -e <string> - searches for an exported symbol. Partial strings
                             that omit the -w switch will generate output
                             from any and all symbols that match the partial
                             pattern, but will take a little longer to
                             perform.

               -s <string> - searches for the symbol of a compound data type
                             that matches the string. Adding the -w "whole
                             word" switch will speed up the search, but the
                             symbol must be exact. Strings having spaces
                             must be wraped in quotes.

                             NOTE: With the -w switch, the string must
                             include the word "struct" before the string
                             being searched. E.g.

                             kabi-lookup -sw "struct pci_dev"

               -d <string> - searches for the declaration of a compound data
                             type and prints its tree to the screen.

               -c <string> - counts the number of times the string pattern
                             is encountered in the database.

               -m <mask>     The mask string limits the search to filenames
                             and subdirectories containing the mask string.

               -q            Limits the search to a depth of one. For
                             struct searches, inhibits printing of the
                             tree from the argument level to the level
                             at which the string is located.

To install from the rpm
-----------------------

RHEL7 and Fedora-22 RPM file can be found at
        http://people.redhat.com/tcamuso/kabitools/

You must install gcc c++ and the boost library first.

yum install gcc-c++
yum install boost
yum install \
     http://people.redhat.com/tcamuso/kabitools/kabitools-3.3-1.el7.x86_64.rpm


To build from scratch
--------------------

1. git clone git@github.com:camuso/kabiparser.git

2. To build the toolkit, you must download and build the sparse
   C-semantic parser from this site.
   http://git.kernel.org/cgit/devel/sparse/sparse.git/

   Build the static libsparse.a and copy it into /usr/lib
   Also copy all the sparse/*.h files into /usr/lib/sparse/.

3. Download the boost library. For fedora users, this will simply
   be "yum install boost". For ubuntu users, "apt-get install boost"
   The kabiparser Makefile expects the boost library to be in
   /usr/lib64 and the boost headers in /usr/include/boost

   If you're using Ubuntu, you will probably have to edit the Makefile
   to point to the locations of these files, if they are not the same
   as fedora.

4. Build the toolkit and put the tools in the correct redhat directories
   off the kernel tree.

   $ make

   $ sudo rsync -Pva \
           kabi-parser kabi-dump kabi-lookup kabi-data.sh makei.sh \
        /usr/sbin

5. From the top of your linux tree, do the following.

   $ makei.sh ./

   $ kabi-data.sh -d ./

   Each of those steps takes about 5 minutes on a core-duo quad-core
   desktop. There are more than 3000 files with over 18000 exported
   symbols and all their dependencies that must be processed.

   There are options to build only subdirectories. You can see the
   options by invoking these scripts without arguments.

   The makei.sh script calls the kernel make to create the preproccesor
   intermediate (".i") files that are needed by kabi-parser to build the
   database.

   The database is distributed as ".kb_dat" files having the same name
   stem as the source ".i" file from which they were created and residing
   in the same source directory.

   These can be cleaned out with "git clean -f", but that will also erase
   files you may want to keep. Instead you can simply do the following.

   $ find . -name \*.kb_dat -exec rm -f '{}' \;


Using kabi-lookup
-----------------

This tool enables the user to determine whether a compound data type,
i.e. struct or union, has any relation to exported symbols. Conversely,
you can use the tool to search for exported symbols to see their entire
dependency tree.

You can also use to tool to count how many times a given symbol appears
in the dependency trees of all the exported symbols in the kernel.

Searches can be generalized or specific. The -w switch makes the search
specific. The -w switch also makes searches faster, since it creates
a hash from the name to search the underlying hash table.

Examples.

$ kabi-lookup -s pci_dev

Searches for all instances of "pci_dev", including such patterns as
"struct pci_device_id".

$ kabi-lookup -sw "struct pci_dev"

NOTE: Quotes are needed around patterns having spaces.

Will search only for exactly "struct pci_dev" and will do so faster.
Exact matches for compound data types must include the "struct" or
"union" declaration.

$ kabi-lookup -m pci -s pci_bus

Searches for all instances of the string "pci_bus" in any and all
subdirectories and files that have "pci" in their name.


$ kabi-lookup -e mlx4_cq

Searches for any and all exported symbols that match "mlx4_cq" and their
argument lists and return values.

$ kabi-lookup -ew mlx4_cq_modify

Will find the one and only unique mlx4_cq_modify exported symbol and
its argument lists and return values.


There is also a -q option for a quiet "less verbose" output.

To see all the options for kabi-lookup, simply invoke it without
arguments.
