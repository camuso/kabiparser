kabiparser
==========

This is a toolkit comprised of the following utilities.

makei.sh    - Uses the kernel make to compile preprocessor .i files.
              To save time, only files that have EXPORT_SYMBOL in them
	      are processsed.

kabi-parser - Parses preprocessor .i files for exported symbols and the
              compound data types on which they depend. The results for
	      each .i file serialized into a data file ending with .kb_dat.
	      Exported symbols and their entire dependency trees are
	      recorded.

	      The data files have the same name stem and reside in the
	      same directory as their .i sources. The data is organized as
	      as a graph using a symbol's crc and its place in the
	      hierarchy of its dependent exported symbol as the "edges"
	      between each vertex.

	      Data is filtered to minimize data file size and maximize
	      performance. Compound data types will include their
	      backpointers, which introduces a bit of redundancy, but
	      maximizes the information in the database.

kabi-data.sh - A shell script wrapper for kabi-parser that invokes it for
               each .i file in the kernel tree. This shell script creates
	       a list of files processed to be used by kabi-lookup tool.

kabi-dump    - Dumps the contents of a serialized .kb_dat file to make it
               humanly readable. It is really only a debugging tool.

kabi-lookup  - Utility that traverses the .kb_dat files looking for symbols
               on which exported symbols depend. The searches are as follows.

	       -s <string> - searches for the symbol of a compound data type
	                     that matches the string. Adding the -w "whole
			     word" switch will speed up the search, but the
			     symbol must be exact. Strings having spaces
			     must be wraped in quotes.

			     NOTE: With the -w switch, the string must
			     include the word "struct" before the string
			     being searched. E.g.

			     kabi-lookup -sw "struct pci_dev"

	       -e <string> - searches for an exported symbol. Partial strings
	                     that omit the -w switch will generate output
			     from any and all symbols that match the partial
			     pattern, but will take a little longer to
			     perform.

	       -d <string> - searches for the declaration of a compound data
	                     type and prints its tree to the screen.

	       -c <string> - counts the number of times the string pattern
	                     is encountered in the database.

               -q            Limits the search to a depth of one. For
	                     struct searches, inhibits printing of the
			     tree from the argument level to the level
			     at which the string is located.

               -u <subdir>   The <subdir> string limits the search to
	                     subdirectories that match the <subdir>
			     string.

To install from the rpm
-----------------------

A Fedora-22 RPM file can be found at http://people.redhat.com/tcamuso/kabitools/

You must install gcc c++ and the boost library first.

yum install gcc-c++
yum install boost
yum install \
     http://people.redhat.com/tcamuso/kabitools/kabitools-3.0-1.el7.x86_64.rpm


To build from scratch
--------------------

1. git clone git@github.com:camuso/kabiparser.git

2. To build the toolkit, you must download and build the sparse
   C-semantic parser from this site.
   http://git.kernel.org/cgit/devel/sparse/sparse.git/

   Build the static libsparse.a and copy it into /usr/lib
   Also copy all the sparse/*.h files into /usr/lib/sparse/.

3. Download the boost library. For fedora users, this will simply
   be "yum install boost". For ubuntu users, "apt-get install boost"
   The kabiparser Makefile expects the boost library to be in
   /usr/lib64 and the boost headers in /usr/include/boost

   If you're using Ubuntu, you will probably have to edit the Makefile
   to point to the locations of these files, if they are not the same
   as fedora.

4. Build the toolkit and put the tools in the correct redhat directories
   off the kernel tree.

   $ make

   $ sudo rsync -Pva \
   	kabi-parser kabi-dump kabi-lookup kabi-data.sh makei.sh \
	/usr/sbin

5. From the top of your linux tree, do the following.

   $ makei.sh ./

   $ kabi-data.sh -d ./

   Each of those steps takes about 5 minutes on a core-duo quad-core
   desktop. There are more than 3000 files with over 18000 exported
   symbols that must be processed.

   There are options to build only subdirectories. You can see the
   options by invoking these scripts without arguments.

   The makei.sh script calls the kernel make to create the preproccesor
   intermediate (".i") files that are needed by kabi-parser to build the
   database.

   The database is distributed as ".kb_dat" files having the same name
   stem as the source ".i" file from which they were created and residing
   in the same source directory.

   These can be cleaned out with "git clean -f", but that will also erase
   files you may want to keep. Instead you can simply do the following.

   $ find . -name \*.kb_dat -exec rm -f '{}' \;


Using kabi-lookup
-----------------

This tool enables the user to determine whether a compound data type,
i.e. struct or union, has any relation to exported symbols. Conversely,
you can use the tool to search for exported symbols to see their entire
dependency tree.

You can also use to tool to count how many times a given symbol appears
in the dependency trees of all the exported symbols in the kernel.

Searches can be generalized or specific. The -w switch makes the search
specific. The -w switch also makes searches faster, since it creates
a hash from the name to search the underlying hash table.

Examples.

$ kabi-lookup -s pci_dev

Searches for all instances of "pci_dev", including such patterns as
"struct pci_device_id".

$ kabi-lookup -sw "struct pci_dev"

NOTE: Quotes are needed around patterns having spaces.

Will search only for exactly "struct pci_dev" and will do so faster.
Exact matches for compound data types must include the "struct" or
"union" declaration.

$ kabi-lookup -u pci -s pci_bus

Searches for all instances of the string "pci_bus" in any and all
subdirectories and files that have "pci" in their name.


$ kabi-lookup -e mlx4_cq

Searches for any and all exported symbols that match "mlx4_cq" and their
argument lists and return values.

$ kabi-lookup -ew mlx4_cq_modify

Will find the one and only unique mlx4_cq_modify exported symbol and
its argument lists and return values.


There is also a -q option for a quiet "less verbose" output.

To see all the options for kabi-lookup, simply invoke it without
arguments.

