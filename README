kabitools
=========

This is a toolkit that is intended to assist in determining whether one
symbol affects or is affected by other symbols in a kABI sense.

The kernel can be compiled so that a database graph is made for each of the
preprocessor, or intermediate ".i" files.

The kabitools can be installed from the following website. Choose the rpm
that matches your distro and architecture.

http://people.redhat.com/tcamuso/kabitools/

The following will be installed.

/usr/lib/ 	    - boost libraries
/usr/include/boost/ - boost headers

/usr/sbin/kabitools.sh
/usr/sbin/kabi-lookup
/usr/sbin/kabi-parser
/usr/sbin/kabi-dump
/usr/sbin/kabi-data.sh
/usr/sbin/makei.sh

-------------------------------------------------------------
Creating the Kernel Graph Files wiith the kabitools.sh script
-------------------------------------------------------------

This is the easiest, most transparent way to create the kernel graph files.
This script requires only one argument, the path to the top of the kernel
tree.

Examples:

# From the top of the kernel tree
kabitools.sh ./

# From any other PWD
kabitools.sh /top/of/my/kernel/tree

There are other methods for those who like to dabble. They are detailed at
the end of this README.

---------------------------------------------
Finding Symbols Affecting or Affected by kABI
---------------------------------------------

kabi-lookup  - Utility that traverses the graph files looking for symbols
	       on which exported symbols depend. The searches are as
	       follows.

	-e sym - Searches for an exported symbol. Partial strings that omit
		 the -w switch will generate output from any and all symbols
		 that match the partial pattern.

	-s sym - Searches for the symbol of a compound data type that
		 matches the string. Adding the -w "whole word" switch will
		 speed up the search, but the symbol must be exact. Strings
		 having spaces must be wraped in quotes.

	-d sym - Search for the declaration of a compound data type and
		 print its members to the screen.

	-c sym - counts the number of times the symbol occurs in the
		 search.

	-l     - Limits search to symbols in the white lists.
		 Must be used with the -w option.
		 Run "make rh-kabi" to create the white lists.

	-m str - The mask string limits the search to pathnames containing
		 the mask string. For example,

		 kabi-lookup -m fs -sw 'struct device'

		 Will search every path having "fs" in its name, e.g.
		 drivers/video/fbsysfs.i and fs/coredump.i

		 If you wish to limit the search to a specific directory, a
		 trailing / must be used, e.g.

		 kabi-lookup -m fs/ -sw 'struct device'
		 kabi-lookup -m drivers/acpi/ -sw 'struct acpi_device'

		 The more unique the -m string, the more limited the
		 search.

	-v	- Verbose output, printing the hierarchy down to the
		  lowest level.

		  All descendants of nonscalar types are printed. This
		  creates a LOT of data, so it's probably better to direct
		  output to a text file for parsing.

	-w	- Whole words only. Default is substring match.

		  With this switch, if the symbol is a struct or union, the
		  string must include the word "struct" or "union" before
		  the symbol being searched.  e.g.

		  kabi-lookup -sw "struct pci_dev"
		  kabi-lookup -sw 'union ipmi_smi_info_union'

	-p path - Path to the top of the kernel tree, if executing in a
		  different directory.


kabi-parser - Parses preprocessor .i files for exported symbols and the
              compound data types on which they depend. The results for
              each .i file are serialized into a data file. Exported
              symbols and their entire dependency trees are recorded.

              The data files have the same name stem and reside in the
              same directory as their .i sources. The data is organized as
              as a map using a symbol's crc and its place in the hierarchy
              of its dependent exported symbol.

              Compound data types will include their backpointers, which
              introduces a bit of redundancy, but maximizes the data.
              Backpointers are followed to only one level below to avoid
              infinite recursion. Nested duplicates are also detected and
              limited for the same reason.
              /usr/sbin/kabi-parser

kabi-dump    - Dumps the contents of a serialized data file to make it
               humanly readable. It is really only a debugging tool.
               /usr/sbin/kabi-dump

makei.sh    - Uses the kernel make to compile preprocessor .i files.
              To save time, only files that have EXPORT_SYMBOL in them
              are processed.
              /usr/sbin/makei.sh

kabi-data.sh - A shell script wrapper for kabi-parser that invokes it for
               each .i file in the kernel tree. This shell script creates
               a list of files processed to be used by kabi-lookup tool.
               /usr/sbin/kabi-data.sh

kernel-make.patch - a patch for the kernel make that will obviate the
              need to use the two shell scripts named above. With this
              patch, the make clean target will also remove the .i
              and .kb_dat files generated by the make.
              /usr/sbin/kernel-make.patch

              From the top of your kernel git tree ...

              $ git apply /usr/shre/kernel-make.patch

To install from the rpm
-----------------------

RHEL7 and Fedora-22 RPM file can be found at
        http://people.redhat.com/tcamuso/kabitools/

You must install gcc c++ and the boost library first.

yum install gcc-c++
yum install boost
yum install \
     http://people.redhat.com/tcamuso/kabitools/kabitools-3.5.el7.x86_64.rpm


To build from scratch
--------------------

1. git clone git@github.com:camuso/kabiparser.git

2. To build the toolkit, you must download and build the sparse
   C-semantic parser from this site.
   http://git.kernel.org/cgit/devel/sparse/sparse.git/

   Build the static libsparse.a and copy it into /usr/lib
   Also copy all the sparse/*.h files into /usr/lib/sparse/.

3. Download the boost library. For fedora users, this will simply
   be "yum install boost". For ubuntu users, "apt-get install boost"
   The kabiparser Makefile expects the boost library to be in
   /usr/lib64 and the boost headers in /usr/include/boost

   If you're using Ubuntu, you will probably have to edit the Makefile
   to point to the locations of these files, if they are not the same
   as fedora.

4. Build the toolkit and put the tools in the correct redhat directories
   off the kernel tree.

   $ make

   $ sudo rsync -Pva \
           kabi-parser kabi-dump kabi-lookup kabi-data.sh makei.sh \
        /usr/sbin

5. From the top of your linux tree, do the following.

   $ makei.sh ./

   $ kabi-data.sh -d ./

   Each of those steps takes about 5 minutes on a core-duo quad-core
   desktop. There are more than 3000 files with over 18000 exported
   symbols and all their dependencies that must be processed.

   There are options to build only subdirectories. You can see the
   options by invoking these scripts without arguments.

   The makei.sh script calls the kernel make to create the preproccesor
   intermediate (".i") files that are needed by kabi-parser to build the
   database.

   The database is distributed as ".kb_dat" files having the same name
   stem as the source ".i" file from which they were created and residing
   in the same source directory.

   These can be cleaned out with "git clean -f", but that will also erase
   files you may want to keep. Instead you can simply do the following.

   $ find . -name \*.kb_dat -exec rm -f '{}' \;


Using kabi-lookup
-----------------

This tool enables the user to determine whether a compound data type,
i.e. struct or union, has any relation to exported symbols. Conversely,
you can use the tool to search for exported symbols to see their entire
dependency tree.

You can also use to tool to count how many times a given symbol appears
in the dependency trees of all the exported symbols in the kernel.

Searches can be generalized or specific. The -w switch makes the search
specific. The -w switch also makes searches faster, since it creates
a hash from the name to search the underlying hash table.

Examples.

$ kabi-lookup -s pci_dev

Searches for all instances of "pci_dev", including such patterns as
"struct pci_device_id".


$ kabi-lookup -sw "struct pci_dev"

NOTE: Quotes are needed around patterns having spaces.

Will search only for exactly "struct pci_dev" and will do so faster.
Exact matches for compound data types must include the "struct" or
"union" declaration.


$ kabi-lookup -m pci -s pci_bus

Searches for all instances of the string "pci_bus" in any and all
subdirectories and files that have "pci" in their name.


$ kabi-lookup -e mlx4_cq

Searches for any and all exported symbols that match "mlx4_cq" and their
argument lists and return values.

$ kabi-lookup -ew mlx4_cq_modify

Will find the one and only unique mlx4_cq_modify exported symbol and
its argument lists and return values.


-------------------------------------------------
Other Methods For Creating the Kernel Graph Files
-------------------------------------------------

*** Patch the kernel Makefiles
******************************.

Patches for the kernel Makefiles are also provided in this kit and are
saved in /usr/share in the following files.

/usr/share/kabitools-fedora-kernel-make.patch
/usr/share/kabitools-rhel-kernel-make.patch

The kabitools script actually applies the appropriate patch to build the
kernel graph, and reverses the patch before exiting.

Example:

# Patch the kernel make
patch -p1 < /usr/share/kabitools-rhel-kernel-make.patch

When you invoke a kernel make with K=1, the graph of the kernel will be
created during the compile of the kernel.

Example:

# Compile the kernel and create the kernel graph
make -j16 K=1


*** makei.sh and kabi-data.sh scripts
*************************************

This method of creating the kernel graph requires both these scripts.

makei.sh - Use this script first to create the preprocessor intermediate
	   ".i" files for the kernel or kernel subdirectory.
	   Must be executed from the top of the kernel tree.

	   Examples:

	   # create .i files for the whole kernel
	   makei.sh ./

	   # create .i files for all files under drivers/acpi
	   makei.sh drivers/acpi

kabi-data.sh -	This script creates the graph files from the .i files
		It requires only one argument, the path to the top of the
		kernel tree.

		Other arguments can be seen by entering the command without
		arguments or with -h switch.

		The most useful of these is -S, which allows you to create
		a graph for just a kernel subdirectory.

		Examples:

		# Create the graph files for the whole kernel from the top
		# of the kernel tree.
		kabi-data.sh -d ./

		# Create the graph files for the whole kernel from a
		# different PWD.
		kabi-data.sh -d /path/to/my/kernel/tree

		# Create the graph files for a subdirectory of the kernel.
		kabi-data.sh -d ./ -s drivers/acpi



