#!/bin/bash
#
# kabitools
#

declare cmdline=kabitools
declare -i cpus=$(cat /proc/cpuinfo | grep processor | wc -l)
declare clean=true
declare patch
declare target=""
declare distro="$(cat /etc/os-release | grep -w ID | cut -d'=' -f2)"
declare -i optcnt=0

# strip outside quotes from the distro string
#
distro=$(sed -e 's/^"//' -e 's/"$//' <<<"$distro")


usagestr=$(
cat <<EOF

kabitools.sh -[jnDh] [target]

	Builds a graph from the preprocessor output of each file compiled.
	Must be invoked from the top of the kernel tree.

	target can be any valid kernel make target including a subdirectory,
	e.g. "virt/" or a module build,	e.g. "M=drivers/char/tpm"
	The kABI graph will be limited to the scope of the build of optarg.

	Default action without the optarg:
		make clean	# can be disabled with -n option
		make -j $cpus	# number of cpus can be set with the -j option
		make modules

	Options
	-j	- Optional number of processors to assign to the make task.
		  Default is all processors: $cpus
		  NOTE: There must be a space between -j and the number.
	-n	- Do not make clean first
	-D      - Delete all the graph files
	-h	- This help screen.

	NOTE:	The graph file extension will be added to .git/info/exclude,
		but will be selectively removed with "kabi-graph -D" command,
		which also removes all the graph files.
\0
EOF
)

no_patch_str=$(
cat <<EOF

$(basename $0) could not find the correct patch for the kernel Makefiles.

Please check for the existence of:

/usr/share/kabitools-rhel-kernel-make.patch
/usr/share/kabitools-fedora-kernel-make.patch

\0
EOF
)

no_os_str=$(
cat <<EOF

$(basename $0) does not handle distro: $distro

\0
EOF
)

not_kernel_str=$(
cat <<EOF

$(basename $0) must be invoked from the top of a kernel tree.

You are here: $PWD

\0
EOF
)

not_redhat_str=$(
cat <<EOF

$(basename $0) must be invoked from the top of a rhel or fedora tree.

Your current distro is: "$distro"
Your current branch is: "$(git branch | grep \*)"

\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit 0
}

# ui_waitonproc
#
# Prints a dot to the screen every half second until the passed PID
# completes.
#
# $1 - PID of process we are waiting for.
# $2 - optional time argument
#
ui_waitonproc() {
    __pid__=$1;
    __time__=1

    [ $# -eq 2 ] && __time__=$2
    while kill -0 $__pid__ > /dev/null 2>&1; do
        echo -n '.';
        sleep $__time__;
    done
}

# run if user hits control-c
#
control_c() {
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	patch -Rs -p1 < "$patch"
	exit 127
}

# delete_linen - deletes the line 'n' from the file
#
# $1 - number of the line to delete
# $2 - file from which to delete the line
#
delete_linen() {
	local tfil="/tmp/__temp__file__"
	local mode=$(stat --format '%a' $2)

	touch $tfil
	chmod $mode $tfil

	awk -v line=$1 '{
		if (NR != line) {
			print $0;
		}
	}' $2 > $tfil
	mv $tfil $2
}

# find_line - return the 1-based line number of the string in the file
#
# Sends a 0 to $3 if not found
#
# $1 - string
# $2 - file
# $3 - number, receives the line number, 0 if not found
#
find_line() {
	local _line_="$1"
	local _file_="$2"
	local _number_

	_line_=$(grep -n "$_line_" "$_file_")
	[ $? -eq 0 ] || { eval $3=0; return 1; }
	_number_=$(echo "$_line_" | cut -d':' -f1)
	eval $3=$_number_
	return 0
}

delete_graph() {
	local mypid
	local linenum
	local line

	echo -n "Deleting graph files.."
	find . -name \*.kbg -exec rm -f '{}' \; &
	mypid=$!
	ui_waitonproc mypid .1
	rm -f redhat/kabi/kabi-datafiles.list

	# delete the kabi-graph lines from .git/info/exclude
	#
	find_line '\*.kbg' .git/info/exclude linenum
	[ $linenum -gt 0 ] && delete_linen $linenum .git/info/exclude
	find_line 'redhat/kabi/kabi-datafiles.list' .git/info/exclude linenum
	[ $linenum -gt 0 ] && delete_linen $linenum .git/info/exclude

	echo
	echo "Done!"
	exit 0
}

main() {

	local kerneltree
	local linenumber

	# Determine if we're in a Linux Kernel directory
	#
	[ -f README ] || { echo -e "$not_kernel_str"; exit 3; }
	kerneltree="$(head -1 README)"
	kerneltree=$(echo $kerneltree)
	[[ ${kerneltree:0:12} == "Linux kernel" ]] || \
		{ echo -e "$not_kernel_str"; exit 4; }

	# Make sure that we are in a rhel or fedora tree
	#
	[ -d redhat ] || { echo -e $not_redhat_str; exit 5; }

	while getopts hnDj: OPTION; do
	    case "$OPTION" in

		h ) 	usage
			;;
		j )	cpus=$OPTARG
			optcnt=$((optcnt + 2))
			;;
		n )	clean=false
			optcnt=$((optcnt + 1))
			;;
		D )	delete_graph
			;;
		* )	echo "unrecognized option"
			usage
			exit 1
	    esac
	done

	shift $optcnt
	target="$1"

	case $distro in
		"rhel")		patch="/usr/share/kabitools-rhel-kernel-make.patch"
				;;
		"fedora")	patch="/usr/share/kabitools-fedora-kernel-make.patch"
				;;
		* )		echo -e "$no_patch_str"
				exit 1
				;;
	esac

	[ -f "$patch" ] || { echo -e "$no_os_str"; exit 2; }

	patch -s -p1 < "$patch"

	$clean && make clean
	make -j $cpus K=1 $target
	patch -Rs -p1 < "$patch"

	# If we haven't already done so, then add the grap files to
	# .git/info/exclude
	#
	find_line '\*.kbg' .git/info/exclude linenumber
	[ $linenumber -eq 0 ] && echo '*.kbg' >> .git/info/exclude
	find_line 'redhat/kabi/kabi-datafiles.list' .git/info/exclude linenumber
	[ $linenumber -eq 0 ] && echo 'redhat/kabi/kabi-datafiles.list' >> .git/info/exclude
}

# trap keyboard interrupt (control-c)
trap control_c SIGINT

main $@
exit 0
